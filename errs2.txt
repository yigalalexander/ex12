In file included from mtmm.c:8:0:
mtmm.h:36:16: error: unknown type name ‘size_t’
 void * malloc (size_t sz);
                ^
mtmm.h:80:29: error: unknown type name ‘size_t’
 void * realloc (void * ptr, size_t sz) ;
                             ^
mtmm.c: In function ‘return_block_to_superblock’:
mtmm.c:151:23: error: incompatible types when initializing type ‘struct BlockList *’ using type ‘BlockList’
  BlockList * trg_list=target->blocks;
                       ^
mtmm.c: In function ‘maintain_invariant’:
mtmm.c:197:3: error: too few arguments to function ‘move_superblock’
   move_superblock(heap, &(hoard.mHeaps[GLOBAL_HEAP]), empty_sb);
   ^
mtmm.c:49:13: note: declared here
 static void move_superblock (MemHeap * source, MemHeap * target, SuperBlock * sb, int class);
             ^
mtmm.c: In function ‘find_thin_sb’:
mtmm.c:212:35: error: invalid type argument of ‘->’ (have ‘SizeClass’)
   pos=heap->sizeClasses[idx_class]->super_blocks_list.head;
                                   ^
mtmm.c: In function ‘move_superblock’:
mtmm.c:303:15: warning: unused variable ‘temp’ [-Wunused-variable]
  SuperBlock * temp;
               ^
mtmm.c: In function ‘scan_heap’:
mtmm.c:348:15: warning: variable ‘prev_sb’ set but not used [-Wunused-but-set-variable]
  SuperBlock * prev_sb;
               ^
mtmm.c: In function ‘malloc_work’:
mtmm.c:433:63: error: request for member ‘mutex’ in something not a structure or union
    pthread_mutex_lock( &(hoard.mHeaps[thread_heap].sizeClasses.mutex) ); /* 3. Lock heap relevant size class in relevant heap */
                                                               ^
mtmm.c:445:66: error: request for member ‘mutex’ in something not a structure or union
     pthread_mutex_unlock( &(hoard.mHeaps[GLOBAL_HEAP].sizeClasses.mutex) ); /* release the global heap, we don't need it */
                                                                  ^
mtmm.c:450:9: warning: passing argument 1 of ‘move_superblock’ from incompatible pointer type [enabled by default]
         source_sb, relevant_class); /* 10. Transfer the superblock s to heap i. */
         ^
mtmm.c:297:13: note: expected ‘struct sCPUHeap *’ but argument is of type ‘struct SizeClass *’
 static void move_superblock (MemHeap * source, MemHeap * target, SuperBlock * sb, int class) {
             ^
mtmm.c:450:9: warning: passing argument 2 of ‘move_superblock’ from incompatible pointer type [enabled by default]
         source_sb, relevant_class); /* 10. Transfer the superblock s to heap i. */
         ^
mtmm.c:297:13: note: expected ‘struct sCPUHeap *’ but argument is of type ‘struct SizeClass *’
 static void move_superblock (MemHeap * source, MemHeap * target, SuperBlock * sb, int class) {
             ^
mtmm.c:463:65: error: request for member ‘mutex’ in something not a structure or union
    pthread_mutex_unlock( &(hoard.mHeaps[thread_heap].sizeClasses.mutex) ); //17. Unlock heap i.
                                                                 ^
mtmm.c: At top level:
mtmm.c:477:15: error: static declaration of ‘malloc_init’ follows non-static declaration
 static void * malloc_init (size_t sz) {
               ^
mtmm.c:35:8: note: previous declaration of ‘malloc_init’ was here
 void * malloc_init (size_t sz); /* Initialization function prototype */
        ^
mtmm.c:505:13: error: static declaration of ‘free’ follows non-static declaration
 static void free (void * ptr) {
             ^
In file included from mtmm.c:17:0:
/usr/include/stdlib.h:483:13: note: previous declaration of ‘free’ was here
 extern void free (void *__ptr) __THROW;
             ^
mtmm.c: In function ‘free’:
mtmm.c:511:15: error: redeclaration of ‘origin_sb’ with no linkage
  SuperBlock * origin_sb; /* superblock from which this was allocated */
               ^
mtmm.c:509:15: note: previous declaration of ‘origin_sb’ was here
  SuperBlock * origin_sb,sb_to_return; /* Origin superblock*/
               ^
mtmm.c:540:5: warning: passing argument 1 of ‘find_thin_sb’ from incompatible pointer type [enabled by default]
     sb_to_return=find_thin_sb(&(origin_heap->sizeClasses[relevant_class]));
     ^
mtmm.c:206:21: note: expected ‘struct sCPUHeap *’ but argument is of type ‘struct SizeClass *’
 static SuperBlock * find_thin_sb(MemHeap * heap) {
                     ^
mtmm.c:540:17: error: incompatible types when assigning to type ‘struct ssuperblock’ from type ‘struct ssuperblock *’
     sb_to_return=find_thin_sb(&(origin_heap->sizeClasses[relevant_class]));
                 ^
mtmm.c:541:21: error: invalid operands to binary != (have ‘struct ssuperblock’ and ‘void *’)
     if (sb_to_return!=NULL){ /*10. Transfer a mostly-empty superblock s1 to heap 0 (the global heap). */
                     ^
mtmm.c:546:6: error: incompatible type for argument 3 of ‘move_superblock’
      move_superblock(origin_heap, &(hoard.mHeaps[GLOBAL_HEAP]),sb_to_return);
      ^
mtmm.c:297:13: note: expected ‘struct ssuperblock *’ but argument is of type ‘struct ssuperblock’
 static void move_superblock (MemHeap * source, MemHeap * target, SuperBlock * sb, int class) {
             ^
mtmm.c:546:6: error: too few arguments to function ‘move_superblock’
      move_superblock(origin_heap, &(hoard.mHeaps[GLOBAL_HEAP]),sb_to_return);
      ^
mtmm.c:297:13: note: declared here
 static void move_superblock (MemHeap * source, MemHeap * target, SuperBlock * sb, int class) {
             ^
mtmm.c: In function ‘realloc’:
mtmm.c:584:4: warning: implicit declaration of function ‘memcpy’ [-Wimplicit-function-declaration]
    if ( memcpy(temp_dst,ptr, copy_size) == temp_dst){ /* Try to copy */
    ^
mtmm.c:584:9: warning: incompatible implicit declaration of built-in function ‘memcpy’ [enabled by default]
    if ( memcpy(temp_dst,ptr, copy_size) == temp_dst){ /* Try to copy */
         ^
mtmm.c: At top level:
mtmm.c:477:15: warning: ‘malloc_init’ defined but not used [-Wunused-function]
 static void * malloc_init (size_t sz) {
               ^
make: *** [libSimpleMTMM.a] Error 1gcc -g -O0 -Wall -m32 -fno-builtin-malloc -fno-builtin-calloc -fno-builtin-realloc -fno-builtin-free  -c mtmm.c 
